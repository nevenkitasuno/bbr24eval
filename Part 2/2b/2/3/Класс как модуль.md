# Модули в C#

## Класс как модуль

**Классы** в C# позволяют инкапсулировать в себя часть кода проекта, и переиспользовать потом эту часть, и с этой точки зрения являются модулями. Переиспользование работает за счёт **композиции** и **наследования**, при этом можно гибко настраивать доступ к составляющим класса с помощью _моификаторов доступа_, а также за счёт _скрытия (shadowing/hiding)_ унаследованных частей.

Наследник может как расширять класс-родитель так и уточнять, специфицировать его. Возможно скомбинировать несколько классов но только с помощью композиции, множественного наследования в C# нет.

# Контракт как модуль

Можно определить модуль без реализации, просто как контракт, или с частичной реализацией, за счёт **абстрактных классов** и **интерфейсов**. Реализуя другие модули можно опираться на несколько контрактов сразу, т.к. в C# можно проверять на соответствие сразу нескольким интерфейсам и ещё опционально одному базовому классу.

# Другие сущности в C# которые можно рассматривать как модули

**Пространства имён** также позволяют сгруппировать код в самодостаточные модули и явно управлять зависимостями между ними.

Для удобного переиспользования кода между проектами есть **NuGet-пакеты**, причём для них предусмотрено и версионирование. Каждая версия пакета является самостоятельным модулем.

В C# результатом компиляции является **сборка**, которую тоже можно рассматривать как модуль - сгруппированный переиспользуемый код. У сборки есть метаданные, также для конфигурации наследования между разными сборками существуют специальные модификаторы доступа.