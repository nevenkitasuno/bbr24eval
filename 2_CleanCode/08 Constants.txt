1) Ввёл константу:

public PowerSet() : base(20000)
{
    _count = 0;
}

//

const int SET_SIZE = 20000;

public PowerSet() : base(SET_SIZE)
{
    _count = 0;
}

2, 3) Ввёл константу:

const int MIN_CAPACITY = 16;

public DynArray()
{
    count = 0;
    MakeArray(MIN_CAPACITY);
}

public void MakeArray(int new_capacity)
{
    if (new_capacity < MIN_CAPACITY)
        new_capacity = MIN_CAPACITY;
    T[] newArray = new T[new_capacity];
    if(array != null)
    {
        Array.Copy(array, newArray, count);
    }
    array = newArray;
    capacity = new_capacity;
}

4, 5) Ввёл константы. Теперь, например, эти параметры проще будет менять для тестов производительности

const float DECREACE_CAPACITY_BY = 1.5;
const float MAX_UNUSED_CAPACITY_MULTIPLIER = 2;

public void Remove(int index)
{
    if (index < 0 || index >= count)
        throw new IndexOutOfRangeException();
        // .net 8+ : ArgumentOutOfRangeException.ThrowIfZero<T>(T, String) and others
    count--;
    for (int i = index; i < count; i++)
    {
        array[i] = array[i + 1];
    }
    if (count < capacity / MAX_UNUSED_CAPACITY_MULTIPLIER)
    {
        int potentialCapacity = (int)(capacity / DECREACE_CAPACITY_BY);
        if (potentialCapacity < MIN_CAPACITY)
            potentialCapacity = MIN_CAPACITY;
        MakeArray(potentialCapacity);
    }
}

6) Ввёл константы, можно уменьшить комментарии:

const int LESS = -1;
const int EQUAL = 0;
const int GREATER = 1;

public int Compare(T v1, T v2)
{
    int result = 0;

    if (typeof(T) == typeof(String)) result = String.Compare(v1.ToString(), v2.ToString()); // version for lexicographic string comparison
    else if (v1 is IComparable<T> comparable) result = comparable.CompareTo(v2); // universal comparison

    if (result < 0) result = -1;
    else if (result > 0) result = 1;

    return result;
    // -1 if v1 < v2
    // 0 if v1 == v2
    // +1 if v1 > v2
}

//

public int Compare(T v1, T v2)
{
    int result = 0;

    if (typeof(T) == typeof(String)) result = String.Compare(v1.ToString(), v2.ToString()); // version for lexicographic string comparison
    else if (v1 is IComparable<T> comparable) result = comparable.CompareTo(v2); // universal comparison

    if (result < 0) return LESS; // v1 is less than v2
    else if (result > 0) return GREATER;

    return EQUAL;
}

7)